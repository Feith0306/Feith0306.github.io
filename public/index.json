[{"content":" 一、输入输出稳定性与增益约束 \u0026#x1f916; 输入输出系统被建模为一个算子 $ G $，将输入信号 $u : {\\mathbb R} \\mapsto {\\mathbb R}^m$ 映射为输出信号 $ y : {\\mathbb R} \\mapsto {\\mathbb R}^p $，即 $ y = G(u)$。\n输入输出信号被认为属于 $ {\\mathcal L}_q[0, \\infty) $ 空间，该空间由满足：\n$$ |f|_q := \\left( \\int_0^{\\infty} |f(t)|^q {\\rm {d}}t \\right)^{1/q} \u0026lt; \\infty $$\n的测度函数构成。这一约束使我们关注信号整体能量而非瞬时行为。\n输入输出映射的最基本要求是因果性（causality）：系统在时间 $ t $ 时刻的输出 $y(t) $ 不能依赖于未来的输入 $ u(s) \\ (s \u0026gt; t) $。数学上，映射 $ G : {\\mathcal L}_q \\to {\\mathcal L}_p $ 是因果的，当且仅当对任意 $ u,v \\in {\\mathcal L}_q $ 和任意 $ T \u0026gt; 0 $，若\n$$ u(t) = v(t) \\quad \\forall t \\in [0, T] , $$\n则有\n$$ (G(u))(t) = (G(v))(t), \\quad \\forall t \\in [0, T]. $$\n这保证了系统对未来信息的不可预测性，是物理实现的基本要求。\n在此基础上，若存在常数 $ \\gamma \u0026gt; 0 $，使得：\n$$ |G(u)|_q \\leq \\gamma |u|_q, $$\n则系统被称为具有有限 $ {\\mathcal L}_q $-增益，该增益 $ \\gamma $ 被称为系统的 ${\\mathcal L}_q $-增益。更进一步，若系统对任意有界输入 $ u \\in {\\mathcal L}_q $ 输出 $ y \\in {\\mathcal L}_q $，则称为 \u0026ldquo;$ {\\mathcal L}_q $-stable\u0026quot;。\n二、小增益定理与闭环稳定性 \u0026#x1f4a5; 当两个系统 $ G_1, G_2 $ 以负反馈互联构成闭环系统时，其输入输出关系将变得复杂。系统互联后，扰动信号可能在环路中反复传播、放大或衰减，因此需要严密的准则判断系统整体的稳定性。若我们将系统互联结构建模为：\n$$\r\\begin{cases}\ry_1 = G_1(u_1), \\quad u_1 = e_1 - y_2, \\\\\ry_2 = G_2(u_2), \\quad u_2 = e_2 + y_1,\r\\end{cases}\r$$\r则可以通过替换得到：\n$$\ru = e - FG(u), \\quad y = G(u), \\quad F = \\begin{bmatrix}\r0 \u0026 I \\\\\r-I \u0026 0\r\\end{bmatrix}.\r$$\r此时系统整体的闭环行为由非线性代数方程 $ u = (I + FG)^{-1} e $ 决定。映射 $ (e_1, e_2) \\mapsto (y_1, y_2) $ 是否定义良好（即闭环是否存在且唯一），并具有 $ {\\mathcal L}_q $-稳定性，成为关键问题。\n小增益定理 给出了这个问题的充分条件之一：\n若两个因果系统 $ G_1, G_2 $ 分别具有有限 $ {\\mathcal L}_q $-增益 $ \\gamma_1, \\gamma_2 $，且满足：\n$$ \\gamma_1 \\cdot \\gamma_2 \u0026lt; 1, $$\n则闭环系统整体是 $ {\\mathcal L}_q $-稳定的，且映射 $ e \\mapsto y $ 是连续、唯一的。\n这一定理以代数乘积揭示了稳定性的本质：在能量意义下，只要反馈回路的总“放大能力”小于1，就能保证系统“收敛”而不是发散。对于线性系统，这一结果直接对应于频域的 $ H_\\infty $ 范数约束；而对于非线性系统，小增益定理提供了从局部 Lipschitz 性或数值界估计出发的通用判据。\n三、无源性系统与能量守恒结构 \u0026#x1f9be; 相较于小增益定理的代数判据，无源性理论（passivity）从物理角度出发，刻画系统在能量传递上的性质。\n一个系统是无源的，意味着它无法生成能量：系统输出给环境的能量不超过它从环境获取的能量。\n形式上，若对系统 $ G $ 存在常数 $ \\beta \\in \\mathbb{R} $，对任意 $ u \\in {\\mathcal L}_2 $ 和任意时间 $ T \u0026gt; 0 $，有：\n$$ \\int_0^T \\langle (G(u))(t), u(t) \\rangle {\\rm {d}}t \\geq \\beta, $$\n则称 $G $ 为无源系统。进一步地，若存在 $ \\varepsilon \u0026gt; 0 $ 使得：\n$$ \\int_0^T \\langle (G(u))(t), u(t) \\rangle {\\rm {d}}t \\geq \\varepsilon |G(u)|_{{\\mathcal L}_2[0,T]}^2 + \\beta, $$\n则称 $ G $ 为严格输出无源系统。\n无源系统的结构性质具有深远影响。首先，它天然满足因果性；其次，两个无源系统的互联系统仍然无源，从而自动继承稳定性和有限增益性质。\n更重要的是，严格输出无源系统必定具有有限 $ {\\mathcal L}_2 $-gain，其增益满足：\n$$\r\\|G(u)\\|_{{\\mathcal L}_2} \\leq \\frac{1}{\\sqrt\\varepsilon} \\|u\\|_{{\\mathcal L}_2} ,\r$$\r因此，无源性不仅是系统的物理属性，也是一种增益约束条件，为稳定性与性能分析提供了结构化的数学工具。\n四、耗散系统 \u0026#x1f93a; 为了将输入输出的增益性和状态空间的 Lyapunov 稳定性统一，提出了耗散系统的框架。\n系统 $ \\dot{x} = f(x, u), \\ y = h(x, u) $ 被称为关于供能率 $ s(u, y) $ 的耗散系统，若存在函数 $ S(x) \\geq 0 $，称为存储函数，使得对任意时间区间 $[t_0, t_1]$：\n$$ S(x(t_1)) - S(x(t_0)) \\le \\int_{t_0}^{t_1} s(u(t), y(t)) {\\rm {d}}t. $$\n这一不等式意味着系统“吸收”的供能 $ s(u, y) $ 不会转化为比 $ S $ 所表示的内部能量更多的输出，换言之，系统具有某种“能量耗散”特性。\n根据所选供能率 $ s(u,y) $ 的不同，可以刻画出不同的系统属性，如下分析。\n\u0026#x1f310; 4-1 供能率的选择与系统性能 耗散系统理论的核心，是通过定义一个输入输出对 $ (u, y) $ 上的供能率函数 $ s(u, y) $，来描述系统的能量如何从输入传递到输出，以及是否会在系统内部以某种形式“被”存储或“耗散”。这一函数并非任意，而是根据我们对系统特性的不同关注点选出。典型的供能率如下：\n\u0026#x1f30d; 1. $ s(u, y) = u^\\top y $ 此时，系统是无源的（Passive）。这是最自然的选择，反映系统从外界吸收的瞬时功率。此时，耗散不等式变为：\n$$ S(x(t_1)) - S(x(t_0)) \\leq \\int_{t_0}^{t_1} u^\\top(t) y(t) {\\rm {d}}t, $$\n表示系统内部存储的能量增量不超过输入与输出之间的能量传递。其背后逻辑是：如果一个系统不会凭空生成能量，那它从输入吸收的功必须转化为内部能量或者输出能量。\n在输入输出映射的形式下，该条件等价于：\n$$ \\int_0^T u^\\top(t) G(u)(t) {\\rm {d}}t \\geq \\beta, $$\n即映射 $ G $ 为无源系统。\n\u0026#x1f30d; 2. $ s(u, y) = u^\\top y - \\varepsilon |y|^2 $ 此时，系统是严格输出无源的（Strict Output Passive）。在实际物理系统中，能量不仅被储存，还可能由于摩擦、电阻等原因被耗散。此时系统对输出信号的能量具有“惩罚项”，形式化为：\n$$ \\int u^\\top y , {\\rm {d}}t \\geq \\varepsilon \\int |y|^2 {\\rm {d}}t + \\beta. $$\n这说明系统输出越大，能量耗散越多。等价于：\n$$ \\int_0^T u^\\top(t) y(t) {\\rm {d}}t - \\varepsilon \\int_0^T |y(t)|^2 {\\rm {d}}t \\geq \\beta. $$\n在无状态模型中，它等价于映射 $ G $ 满足：\n$$ |G(u)|_{{\\mathcal L}_2}^2 \\leq \\frac{1}{\\varepsilon} \\int u^\\top G(u) , {\\rm {d}}t. $$\n因此，该供能率刻画的是输出能量耗散对输入功率的约束，其物理意义在于系统能从输出“泄露能量”。\n\u0026#x1f30d; 3. $ s(u, y) = \\frac{1}{2} \\gamma^2 |u|^2 - \\frac{1}{2} |y|^2 $ 此时，系统具有有限 $ {\\mathcal L}_2 $-增益，不超过 $ \\gamma $。该形式直接对应于系统从输入信号到输出信号的增益控制。若存在存储函数 $ S(x) $ 使得：\n$$ S(x(t_1)) - S(x(t_0)) \\leq \\int_{t_0}^{t_1} \\left( \\frac{1}{2} \\gamma^2 |u(t)|^2 - |y(t)|^2 \\right) {\\rm {d}}t, $$\n则可推出：\n$$\r\\|y\\|_{{\\mathcal L}_2}^2 \\leq \\gamma^2 \\|u\\|_{{\\mathcal L}_2}^2 + 2 S(x_0),\r$$\r这说明系统的输出能量不会超过输入能量的 $ \\gamma^2 $ 倍，加上初始能量的一个常数项。若 $ S(x) = 0 $，这就成了标准的 $ {\\mathcal L}_2 $-增益界定。\r\u0026#x1f30d; 4. $ s(u, y) = -|y|^2 $ 此时，系统输出能量呈现衰减趋势。这是一个强约束：系统的能量不但不能增加，甚至其输出总能量必须“亏损”。从不等式：\n$$ S(x(t_1)) - S(x(t_0)) \\leq - \\int_{t_0}^{t_1} |y(t)|^2 {\\rm {d}}t, $$\n可知只要输出有能量，存储函数必然下降。这是某些无源耗散系统（如阻尼结构）的典型模型，表明系统必须将输出转化为内部的损耗耗散，直至最终达到稳定。\n\u0026#x1f30d; 5. $ s(u, y) = |y|^2 - \\gamma^2 |u|^2 $ 此时，系统放大能力有限，适用于构造 $ H_\\infty $ 控制目标。这是一种对偶形式，更倾向于用于性能评估。若系统关于该 $ s(u, y) $ 是耗散的，则必然满足：\n$$ \\int |y|^2 {\\rm {d}}t \\leq \\gamma^2 \\int |u|^2 {\\rm {d}}t + S(x_0), $$\n进而推出增益约束：\n$$\r\\|y\\|_{{\\mathcal L}_2} \\leq \\gamma \\|u\\|_{{\\mathcal L}_2}.\r$$\r它是最直接的 $ H_\\infty $ 范数定义形式，用作控制设计中的目标函数。该供能率的优势在于它对输出信号进行直接约束，适用于性能评估（如抗扰动、最坏场景最小化等场景）。\r\u0026#x1f310;\t4-2 available storage 定义：\n$$\rS_a(x) := \\sup_{u \\in {\\mathcal L}_2} \\left\\{ - \\int_0^\\infty s(u(t), y(t)) {\\rm {d}}t \\right\\}, \\quad x(0) = x.\r$$\r该函数描述从当前状态 $ x $ 出发，系统在所有可行输入作用下，**所能向外界“释放”的最大能量**。其物理含义与热力学中的“可用能”相同，表明状态 $ x $ 所蕴含的“控制势能”极限。\r从控制意义看：\n若 $ S_a(x) = 0 $，说明此状态下系统无法向外界输出能量，是耗尽状态； 若 $ S_a(x) \u0026gt; 0 $，说明存在输入使系统输出净能量，状态具有能量转换能力。 数学上，available storage 还有如下性质：\n它是所有存储函数的下界，即：若 $ S(x) $ 是任意使系统耗散的函数，则： $$ S_a(x) \\leq S(x), \\quad \\forall x. $$\n它自身就是一个存储函数； 在 passivity 条件下，$ s(u, y) = u^\\top y $，可得： $$ \\int_0^T u^\\top y , {\\rm {d}}t \\geq -S_a(x(0)). $$\n这为系统耗散性提供了最小能量约束，有助于进行能量一致性判断与系统设计下界估计。\n五、$ H_\\infty $ 控制问题 \u0026#x1f50d; 考虑非线性系统：\n$$ \\dot{x} = f(x) + g(x) u + k(x) d, $$\n其中：$x \\in \\mathbb{R}^n$：系统状态；$u \\in \\mathbb{R}^{n_u}$：控制输入；$d \\in \\mathbb{R}^{n_d}$：外部扰动；$f(x), g(x), k(x)$ 为局部 Lipschitz 连续函数。\n系统的性能输出定义为：\n$$ z(x, u) = Q(x) + u^\\top R u, $$\n其中 $Q(x) \\geq 0$ 是正定函数，$R \\succ 0$ 是控制输入的权重矩阵。性能目标为：对于任意扰动 $d \\in \\mathcal{L}_2$，闭环系统满足：\n$$ \\int_0^\\infty \\left( Q(x(t)) + u^\\top(t) R u(t) \\right) {\\rm {d}}t \\leq \\gamma^2 |d|^2_{\\mathcal{L}_2}. $$\n这是一种标准的非线性 $H_\\infty$ 控制形式，目标是以最小控制代价抑制最强扰动。\n\u0026#x1f4a1; 5-1. 耗散系统 $H_\\infty$ 性能指标 构造供能率函数：\n$$ s(d, x, u) := Q(x) + u^\\top R u - \\gamma^2 |d|^2, $$\n若存在光滑非负函数 $V(x)$ 使得系统沿解轨迹满足：\n$$ \\dot{V}(x) \\leq - s(d, x, u) , $$\n则沿系统轨迹有\n$$ \\frac{{\\rm{d}}}{{{\\rm{d}}t}}V\\left( {x\\left( t \\right)} \\right) \\le - Q\\left( x \\right) - {u^\\top}Ru + {\\gamma ^2}{\\left| d \\right|^2} $$\n则通过积分可得：\n$$ V(x(0)) \\geq \\int_0^\\infty \\left( Q(x(t)) + u^\\top(t) R u(t) \\right) {\\rm {d}}t - \\gamma^2 |d|^2_{\\mathcal{L}_2}, $$\n即系统满足期望的 $H_\\infty$ 性能指标。\n\u0026#x1f4a1; 5-2. HJI 推导 考虑沿系统轨迹对 $V(x)$ 求导：\n$$ \\dot{V}(x) = \\nabla V(x)^\\top \\left( f(x) + g(x) u + k(x) d \\right). $$\n代入上述不等式，有：\n$$ \\nabla V^\\top f(x) + \\nabla V^\\top g(x) u + \\nabla V^\\top k(x) d \\leq - Q(x) - u^\\top R u + \\gamma^2 |d|^2. $$\n整理后构造 Hamiltonian：\n$$ H(x, \\nabla V, u, d) := \\nabla V^\\top f(x) + Q(x) + \\nabla V^\\top g(x) u + u^\\top R u + \\nabla V^\\top k(x) d - \\gamma^2 |d|^2. $$\n要求：\n$$ \\inf_{u} \\sup_{d} H(x, \\nabla V, u, d) \\leq 0, $$\n即系统在最坏扰动下依然满足性能限制。\n\u0026#x1f4a1; 5-3. 扰动与控制的最优化 (1) 对扰动 $d$ 的极大化（扰动 $d$ 试图最大化供能）： 求：\n$$\r\\sup_d \\left\\{ \\nabla V^\\top k(x) d - \\gamma^2 \\|d\\|^2 \\right\\}\r$$\r最优扰动为：\n$$ d^* = \\frac{1}{2\\gamma^2} k(x)^\\top \\nabla V(x) $$\n对应最大值为：\n$$ \\frac{1}{4\\gamma^2} | \\nabla V^\\top k(x) |^2. $$\n(2) 对控制输入 $u$ 的极小化（控制 $u$ 试图最小化供能）： 求：\n$$\r\\inf _u \\left\\{ \\nabla V^\\top g(x) u + u^\\top R u \\right\\} $$\r最优控制为：\n$$ u^* = - \\frac{1}{2} R^{-1} g(x)^\\top \\nabla V(x) $$\n对应最小值为：\n$$ -\\frac{1}{4} \\nabla V^\\top g(x) R^{-1} g(x)^\\top \\nabla V. $$\n最优控制为：\r$$ u^* = - \\frac{1}{2} R^{-1} g(x)^\\top \\nabla V(x) $$\n对应最小值为：\n$$ -\\frac{1}{4} \\nabla V^\\top g(x) R^{-1} g(x)^\\top \\nabla V. $$\n\u0026#x1f4a1; 5-4. HJI 不等式最终形式 将控制项与扰动项代入 Hamiltonian，得到最终形式的 HJI 不等式：\n$$ \\nabla V^\\top f(x) + Q(x) - \\frac{1}{4} \\nabla V^\\top g(x) R^{-1} g(x)^\\top \\nabla V + \\frac{1}{4\\gamma^2} |\\nabla V^\\top k(x)|^2 \\leq 0. $$\n若存在正定光滑函数 $V(x)$ 满足上述不等式，则控制器：\n$$ u(x) = -\\frac{1}{2} R^{-1} g(x)^\\top \\nabla V(x) $$\n确保系统满足性能约束：\n$$ \\int_0^\\infty \\left( Q(x(t)) + u^\\top(t) R u(t) \\right) dt \\leq \\gamma^2 |d|^2_{\\mathcal{L}_2}. $$\n","permalink":"http://localhost:1313/posts/l_2/","summary":"从耗散系统理论出发，分析非线性系统在面对扰动输入时的 H∞ 控制问题，推导相应的 HJI 不等式，并给出最优控制律的结构。适用于理解非线性控制中的能量约束。","title":"L2相关概念整理"},{"content":"This article offers the sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested Unordered list Fruit Apple Orange Banana Dairy Milk Cheese Nested Ordered list Fruit Apple Orange Banana Dairy Milk Cheese Third item Sub One Sub Two Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/posts/my_profile/","summary":"\u003cp\u003eThis article offers the sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"My personal profile"},{"content":"\u0026#x1f680; 一、问题描述 以前从本地 pull/push 文件向 github 仓库远程操作时，没有任何问题，今天操作出现如下报错：\nbash $ git pull ssh: connect to host github.com port 22: Connection refused fatal: Could not read from remote repository. ​ Please make sure you have the correct access rights and the repository exists. 提示链接 github 的 22 端口被拒绝。\n\u0026#x26a1; 二、解决方案 修改 SSH 的 config 文件。在 C:\\Users\\用户名\\.ssh 目录下，新建一个名为 config 的文件，内容如下：（如果目录下有 config 文件，直接在文件里添加即可） Host github.com HostName github.com Port 443 切换端口为443。\n打开 Git Bash，输入以下命令，测试连接： ssh -T git@github.com 如果连接成功，会显示以下信息： Hi username! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 重新 pull/push 即可。 \u0026#x1f3af; 三、报错原因 可能是因为 SSH 的 config 文件中配置的端口与实际使用的端口不一致。 用了 VPN 导致的网络配置问题。 ","permalink":"http://localhost:1313/posts/git_port/","summary":"这个文档用于解决 Github 端口连接报错问题。","title":" Github 端口连接 "},{"content":"1. 安装 VS code 插件：Latex Workshop \u0026#x1f680; 在 VS code 扩展商店中找到 Latex Workshop 插件（如下），安装即可。 2. 打开一个 .tex 文件 \u0026#x1f916; 可以看到 VS code 已经自动高亮文档内容 3. 配置 Latex Workshop \u0026#x1f50d; 按 F1，搜索setjson，打开配置文件 \u0026#x1f50d; 可以看到在项目中生成了.vscode文件夹，在其中打开settings.json文件，添加如下代码： { \u0026#34;latex-workshop.latex.autoBuild.run\u0026#34;: \u0026#34;never\u0026#34;, # 从不自动编译 \u0026#34;latex-workshop.showContextMenu\u0026#34;: true, # 显示右键菜单，出现\u0026#34;Build Latex Project\u0026#34;选项 \u0026#34;latex-workshop.intellisense.package.enabled\u0026#34;: true, # 启用包自动完成 \u0026#34;latex-workshop.message.error.show\u0026#34;: false, # 不显示错误信息（从终端获取） \u0026#34;latex-workshop.message.warning.show\u0026#34;: false, # 不显示警告信息（从终端获取） \u0026#34;latex-workshop.latex.tools\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; # 文件所在路径可以为中文，若为\u0026#34;%DOC\u0026#34;则不可有中文 ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;-pdf\u0026#34;, \u0026#34;-outdir=%OUTDIR%\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;%DOCFILE%\u0026#34; ] } ], \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;XeLaTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;PDFLaTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;BibTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;bibtex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;LaTeXmk\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;xelatex -\u0026gt; bibtex -\u0026gt; xelatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;xelatex\u0026#34;, \u0026#34;xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;pdflatex\u0026#34;, \u0026#34;pdflatex\u0026#34; ] }, ], \u0026#34;latex-workshop.latex.clean.fileTypes\u0026#34;: [ \u0026#34;*.aux\u0026#34;, \u0026#34;*.bbl\u0026#34;, \u0026#34;*.blg\u0026#34;, \u0026#34;*.idx\u0026#34;, \u0026#34;*.ind\u0026#34;, \u0026#34;*.lof\u0026#34;, \u0026#34;*.lot\u0026#34;, \u0026#34;*.out\u0026#34;, \u0026#34;*.toc\u0026#34;, \u0026#34;*.acn\u0026#34;, \u0026#34;*.acr\u0026#34;, \u0026#34;*.alg\u0026#34;, \u0026#34;*.glg\u0026#34;, \u0026#34;*.glo\u0026#34;, \u0026#34;*.gls\u0026#34;, \u0026#34;*.ist\u0026#34;, \u0026#34;*.fls\u0026#34;, \u0026#34;*.log\u0026#34;, \u0026#34;*.fdb_latexmk\u0026#34; ], \u0026#34;latex-workshop.latex.autoClean.run\u0026#34;: \u0026#34;onFailed\u0026#34;, # 编译失败时自动清理上述类型的辅助文件（\u0026#34;OnBuilt\u0026#34;:无论编译是否成功，都清除辅助文件；\u0026#34;never\u0026#34;:无论编译是否成功，都不清除） \u0026#34;latex-workshop.latex.recipe.default\u0026#34;: \u0026#34;lastUsed\u0026#34;, # 编译时使用上次使用的编译方式 \u0026#34;latex-workshop.view.pdf.internal.synctex.keybinding\u0026#34;: \u0026#34;double-click\u0026#34; # 点击 pdf 可以跳转到相应代码位置 } 4. 设置编译快捷键（可选） \u0026#x1f50d; 左下角打开设置 -\u0026gt; Keyboard Shortcut-\u0026gt; 搜索recipe -\u0026gt; 双击中间的When -\u0026gt; 按下想要使用的快捷键 \u0026#x1f50d; 选择编译方式 \u0026#x1f50d; 直接运行.tex文件也可以编译 5. 测试 ","permalink":"http://localhost:1313/posts/vs_tex/","summary":"这个文档用于说明如何使用 VS code 编译 .tex 文件。","title":"VS code 编译 .tex 文件"},{"content":"\u0026#x1f9d0; What is the file with the suffix \u0026ldquo;.bat\u0026rdquo; ? 后缀为“.bat”的文档是一个批处理文件。它是一种可执行文件，其中包含由操作系统执行的一系列命令。批处理文件通常用于自动化涉及多个命令的任务。它们通常用于安装软件、配置系统设置或执行其他需要多个步骤的任务。 \u0026#x1f680; Example 这是一个批处理文件的示例，它将“open with VS code”选项添加到Windows右键菜单中，允许用户直接右键单击文件夹或其背景（空白），并在 VS code 中打开文件夹。\n@echo off\rREG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\u0026#34; /ve /t REG_SZ /d \u0026#34;open here with VS Code\u0026#34; /f\rREG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\\command\u0026#34; /ve /t REG_SZ /d \u0026#34;\\\u0026#34;E:\\VS code\\Microsoft VS Code\\Code.exe\\\u0026#34; \\\u0026#34;%%V\\\u0026#34;\u0026#34; /f\recho VS Code Successful！\rpause \u0026#x1f4de; @echo off 上述代码的第一行关闭命令行窗口的响应，以防止每次执行命令时它出现在屏幕上，使界面更清晰。\n\u0026#x1f5a5;\u0026#xfe0f; REG ADD \u0026quot;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\u0026quot; /ve /t REG_SZ /d \u0026quot;open here with VS Code\u0026quot; /f 将键或值添加到Windows注册表。\n\u0026#x1f50d; KEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code : 在Windows资源管理器的右键菜单中创建一个新选项“open with VS code”。 \u0026#x1f50d; /ve : 创建一个默认值（未命名键值）。 \u0026#x1f50d; /t REG_SZ : 将值的数据类型设置为REG_SZ（字符串）。 \u0026#x1f50d; /d \u0026quot;open here with VS Code\u0026quot; : 设置注册表的值，即右键菜单中显示的文本（open here with VS code）。 \u0026#x1f50d; /f : 强制操作覆盖任何现有键或值。 \u0026#x1f5a5;\u0026#xfe0f; REG ADD \u0026quot;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\\command\u0026quot; /ve /t REG_SZ /d \u0026quot;\\\u0026quot;E:\\VS code\\Microsoft VS Code\\Code.exe\\\u0026quot; \\\u0026quot;%%V\\\u0026quot;\u0026quot; /f\n\u0026#x1f50d; HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\\command: 定义单击菜单项后要执行的命令。 \u0026#x1f50d; \u0026quot;E:\\VS code\\Microsoft VS Code\\Code.exe\u0026quot;: VS code 的可执行文件路径。 \u0026#x1f50d; \u0026quot;%%V\u0026quot;: 当前文件夹路径，即用户右键单击的文件夹。 \u0026#x1f5a5;\u0026#xfe0f; echo VS Code Successful！\n\u0026#x1f50d; 在命令行窗口中显示提示，表明注册表已成功修改。 \u0026#x1f4c1; Operation effect \u0026#x1f446; Right-click the folder or blank space inside the folder, select \u0026ldquo;Open with VS Code\u0026rdquo;. ","permalink":"http://localhost:1313/posts/bat_explain/","summary":"这个文档简要介绍了 .bat 文件的作用，以及如何通过 .bat 右击文件夹在 VS code 中打开。","title":"什么是 .bat 文件？"}]